\section{Measurement Setup}
\label{sec:measurement_setup}

To research the influence of different initial window size on TCP and the
network, we chose the network virtualization framework Mininet~\cite{mininet}.
Mininet exploits existing os virtualization and resource management features of
the Linux kernel, namely Network namespaces~\cite{network_namespaces} and
Cgroups~\cite{cgroups}, to simulate multiple networks and peers on a single
host. Because no virtual machines are involved and Linux can make advantage of
zero-copy mechanism, the overhead of these Network namespaces is low. It can
easily simulate 10GbE-Networks using commodity PC-Hardware. Mininet also
integrates other features such as traffic control and OpenFlow, so one can build
arbitrary network topologies and conditions. To create and configure networks
Mininet exposes a Python API and allow to interact with network namespaces at
runtime by giving shell access.

\input{topology}

For our network topology we have chosen the following setup: Both Client and
Server are represented by host. They are connected via virtual ethnernet pairs
to a software bridge, which represents our router. The veth pair of the server
stands for the Uplink the client has over the internet to our server. The other
one is the local area network, where both client and router are included.
To limit the bandwith and set a forwarding delay, we applied policies using
Linux's Traffic Control~\cite{tc}.

%# Testsetup
%
%- Client <-1Gbit/s-> Router <-Uplink-> Server
%- Client: curl, HTTP-Header von Chrome
%- Server: Nginx 1.8.0
%- Dateien von 1kb bis 16384kb
%- tcp cubic
%
%## TCP Fenster auf 16mb begrenzt
%net.ipv4.tcp_window_scaling = 1
%
%net.core.wmem_max = 16777216
%net.ipv4.tcp_wmem = 10240 87380 16777216
%net.ipv4.tcp_rmem = 10240 87380 16777216
%
%## Grenzen der Simulation:
%- Nur ein Link zum Server simuliert
%  -> aber häufig der Flaschhals zwischen Client und Server
%- Nur den Linux-TCP Stack und dessen Standardeinstellungen betrachtet
%- Nur symmetrische Bandbreiten getestet
%  -> sollte keinen Einfluss haben,
%  da Acknowledges verhältnissmäßig zur übertragenen Nachricht klein sind.
%
%- bw = (cwnd * mtu) / rtt
%- rto... retransmission timeout
%  - time before unacknowledged packet is resent
%  - zu groß -> Verzögerungen, doppelte acks.
%  - zu klein -> doppelte Packete verschicken
%  - z.B. laut RFC rto = srtt + 4 * varrtt
